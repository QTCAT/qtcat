#' @title A genotype object constructor
#'
#' @description Constructs an S3 object containing SNP matrix and SNP
#' hierarchy. This is needed for \code{\link{qtcatHit}} as input.
#'
#' @param snp An object of S4 class \linkS4class{snpData}.
#' @param snpClust An object of class \code{\link{qtcatClust}}.
#' @param absCor Vector of absolute value of correlations considered in the
#' hierarchy.
#' @param min.absCor Minimum absolute value of correlation considered. A value
#' in the range from 0 to 1.
#'
#' @examples
#' # file containing example data for SNP data
#' gfile <- system.file("extdata/snpdata.csv", package = "qtcat")
#' snp <- read.snpData(gfile, sep = ",")
#' clust <- qtcatClust(snp)
#'
#' # Construct geotype object
#' geno <- qtcatGeno(snp, clust)
#'
#' @importFrom hit as.hierarchy
#' @importFrom methods is
#' @export
qtcatGeno <- function(snp, snpClust, absCor, min.absCor = 0.5) {
  stopifnot(is(snp, "snpData"))
  stopifnot(is(snpClust, "qtcatClust"))
  if (!setequal(names(snpClust$clusters), colnames(snp)))
    stop("Names of 'snp' and 'snpClust' differ")
  if (is.null(names <- snpClust$medoids))
    names <- names(snpClust)
  # TODO: chack alleleFreq?
  if (any(is.na(snp@snpData)))
    stop("Missing values in 'snp' are not allowed")
  # TODO: use clustering for imputation of SNPs!
  desMat <- as.matrix(snp[, colnames(snp) %in% names])
  if (missing(absCor))
    hier <- as.hierarchy(snpClust$dendrogram, 1 - min.absCor,
                         names = colnames(desMat))
  else
    hier <- as.hierarchy(snpClust$dendrogram, 1 - min.absCor, 1 - absCor,
                      colnames(desMat))
  out <- list(x = desMat,
              hierarchy = hier,
              clusters = snpClust$clusters,
              medoids = snpClust$medoids,
              positions = getPos(snp))
  class(out) <- "qtcatGeno"
  out
}


#' @title A phenotype object constructor
#'
#' @description Constructs an S3 object containing phenotype and if
#' additional covariats exist a design matrix of those. This is needed for
#' \code{\link{qtcatHit}} as input.
#'
#' @param names A vector of individual names of length 'n'.
#' @param pheno A vector of length 'n' or a matrix size 'n x 2' in case of
#' binomial family. This contains the phenotypic observations.
#' @param family A character string specifying the family of the phenotype
#' distribution. Either "gaussian" (default) or "binomial".
#' @param covariates A matrix typically generated by a call of
#' \code{\link[stats]{model.matrix}}. It contain additional variables
#' influencing the phenotype e.g. environmental and experimental components.
#'
#' @examples
#' # file containing example data for a phenotype.
#' pfile <- system.file("extdata/phenodata.csv", package = "qtcat")
#' pdat <- read.csv(pfile, header = TRUE)
#'
#' # Construct phenotype object
#' pheno <- qtcatPheno(names = pdat[, 1],
#'                     pheno = pdat[, 2],
#'                     covariates = model.matrix(~ pdat[, 3]))
#'
#' @export
qtcatPheno <- function(names, pheno, family = "gaussian", covariates = NULL) {
  match.arg(family, c("gaussian", "binomial"))
  nn <- length(names)
  if (any(is.na(pheno)))
    stop("Missing values in 'pheno' are not allowed")
  if (!is.null(covariates)) {
    if (is.matrix(covariates)) {
      nc <- nrow(covariates)
      if (all(covariates[, 1] == 1))
        covariates <- covariates[, -1, drop = FALSE]
    } else {
      stop("'covariates' has to be a 'matrix'")
    }
  } else {
    covariates <- matrix(nrow = nn, ncol = 0L)
    nc <- nn
  }
  if (is.vector(pheno)) {
    np <- length(pheno)
  } else if (is.matrix(pheno) && family == "binomial") {
    if (ncol(pheno) > 2)
      stop("'phone' has more than two columns which is not allowed")
    np <- nrow(pheno)
  } else {
    stop("'pheno' has to be a 'vector' or in in case of binomial family a 'matrix'")
  }
  if (nn == nc && nn == np)
  out <- list(names = as.character(names),
              pheno = pheno,
              covariates = covariates)
  class(out) <- "qtcatPheno"
  out
}


#' @title Fitting Hierarchical Inference Testing
#'
#' @description Hierarchical inference testing for phenotype-SNP association.
#'
#' @param pheno An object of class \code{\link{qtcatPheno}}.
#' @param geno An object of class \code{\link{qtcatGeno}}.
#' @param B A integer indicating the number of sample-splits.
#' @param p.samp1 A value specifying the fraction of data used for the LASSO
#' sample-split. The ANOVA sample-split is \code{1 - p.samp1}.
#' @param nfolds Number of folds (default is 5).
#' See \code{\link[glmnet]{cv.glmnet}} for more details.
#' @param lambda.opt Criterion for optimum selection of cross validated lasso.
#' Either "lambda.1se" (default) or "lambda.min". See
#' \code{\link[glmnet]{cv.glmnet}} for more details.
#' @param alpha A single value or a vector of values in the range of 0 to 1 for
#' the elastic net mixing parameter. If more than one value are given, the best
#' is selected during cross-validation.
#' @param gamma Vector of gamma-values used in significant estimation.
#' @param max.p.esti Maximum for computed p-values. All p-values above this
#' value are set to one. Small \code{max.p.esti} values reduce computing time.
#' @param mc.cores Number of cores for parallelising. Theoretical maximum is
#' \code{'B'}. For details see \code{\link[parallel]{mclapply}}.
#' @param trace If \code{TRUE} it prints current status of the program.
#' @param ... additional arguments for \code{\link[glmnet]{cv.glmnet}}.
#'
#' @examples
#' # If you want to run the examples, use:
#' # example(qtcatHit, run.dontrun = TRUE)
#' \dontrun{
#' # files containing example data for SNP data and the phenotype
#' pfile <- system.file("extdata/phenodata.csv", package = "qtcat")
#' gfile <- system.file("extdata/snpdata.csv", package = "qtcat")
#' pdat <- read.csv(pfile, header = TRUE)
#' snp <- read.snpData(gfile, sep = ",")
#' clust <- qtcatClust(snp)
#' geno <- qtcatGeno(snp, clust)
#' pheno <- qtcatPheno(names = pdat[, 1],
#'                     pheno = pdat[, 2],
#'                     covariates = model.matrix(~ pdat[, 3]))
#'
#' # fitting HIT
#' fitted <- qtcatHit(pheno, geno)
#' }
#'
#' @importFrom methods is
#' @export
qtcatHit <- function(pheno, geno, B = 50, p.samp1 = 0.5,
                     nfolds = 5, lambda.opt = "lambda.1se", # "lambda.min" as defauld ?
                     alpha = seq(1, .5, length.out = 11),
                     gamma = seq(0.05, 0.99, by = 0.01),
                     max.p.esti = 1, mc.cores = 1, trace = FALSE, ...) {
  stopifnot(is(pheno, "qtcatPheno"))
  stopifnot(is(geno, "qtcatGeno"))
  id <- intersect(pheno$names, rownames(geno$x))
  if (!length(id))
    stop("The ID intersect of 'pheno' and 'geno' is emty")
  if (length(id.uniqueGeno <- setdiff(rownames(geno$x), id)))
    cat("The following individuals are part of 'geno' but not of 'pheno':\n",
            paste(id.uniqueGeno, collapse = " "), "\n")
  if (length(id.uniquePheno <- setdiff(pheno$names, id)))
    cat("The following individuals are part of 'pheno' but not of 'geno':\n",
            paste(id.uniquePheno, collapse = " "), "\n")
  phenoInx <- which(pheno$names %in% id)
  genoInx <- match(pheno$names[phenoInx], rownames(geno$x))
  if (ncol(pheno$covariates) == 0L)
    x <- geno$x[genoInx, ]
  else
    x <- cbind(geno$x[genoInx, ], pheno$covariates[phenoInx, ])
  y <- pheno$pheno[phenoInx]
  fitHit <- hit(x, y, geno$hierarchy, pheno$family,
                B, p.samp1, nfolds, lambda.opt, alpha,
                gamma, max.p.esti, mc.cores,
                trace, standardize = FALSE)
  out <- c(fitHit, geno[3L:5L])
  class(out) <- c("hit", "qtcatHit")
  out
}


#' @title Summarize results of Hierarchical Inference Test
#'
#' @description Summarizing the QTCs (significant cluster of SNPs) and their
#' position at the genome.
#'
#' @param object An object of class \code{\link{qtcatHit}}.
#' @param alpha An alpha level for significance estimation.
#' @param min.absCor Minimum absolute value of correlation considered.
#'
#' @examples
#' # If you want to run the examples, use:
#' # example(qtcatQtc, run.dontrun = TRUE)
#' \dontrun{
#' # files containing example data for SNP data and the phenotype
#' pfile <- system.file("extdata/phenodata.csv", package = "qtcat")
#' gfile <- system.file("extdata/snpdata.csv", package = "qtcat")
#' pdat <- read.csv(pfile, header = TRUE)
#' snp <- read.snpData(gfile, sep = ",")
#' clust <- qtcatClust(snp)
#' geno <- qtcatGeno(snp, clust)
#' pheno <- qtcatPheno(names = pdat[, 1],
#'                     pheno = pdat[, 2],
#'                     covariates = model.matrix(~ pdat[, 3]))
#' fitted <- qtcatHit(pheno, geno)
#'
#' # Summarizing the QTCs (loci37, loci260, and loci367 are causal)
#' qtcatQtc(fitted)
#' }
#'
#' @importFrom hit hit
#' @importFrom methods is
#' @export
qtcatQtc <- function(object, alpha = 0.05, min.absCor = 0.05) {
  stopifnot(is(object, "qtcatHit"))
  y <- summary(object, alpha, 1 - min.absCor)
  signames <- rownames(y)
  sigclust <- match(signames, object$medoids)
  sigClust <- matrix(0, length(object$clusters), 3L)
  sigClust[, 2L] <- 1
  for (i in seq_along(signames)) {
    inx <- which(object$clusters == sigclust[i])
    sigClust[inx, ] <- matrix(unlist(y[signames[i], ]),
                              length(inx), 3L, byrow = TRUE)
  }
  rownames(sigClust) <- names(object$clusters)
  sigClust[, 2L] <- 1 - sigClust[, 2L]
  colnames(sigClust) <- c(colnames(y)[1L], "absCor", colnames(y)[3L])
  sigClust <- as.data.frame(sigClust[sigClust[, 1L] != 0, ,drop = FALSE])
  out <- cbind(t(object$positions[, rownames(sigClust), drop = FALSE]),
                    sigClust)
  out
}


#' @title Fitting a Linear Model to medoids
#'
#' @description Linear model between phenotype and medoids of QTCs (significant
#' SNP clusters).
#'
#' @param object An object of class \code{\link{qtcatHit}}.
#' @param pheno An object of class \code{\link{qtcatPheno}}.
#' @param geno An object of class \code{\link{qtcatGeno}}.
#' @param alpha An alpha level for significance estimation.
#' @param min.absCor Minimum absolute value of correlation considered.
#'
#' @examples
#' # If you want to run the examples, use:
#' # example(medoidsLm, run.dontrun = TRUE)
#' \dontrun{
#' # files containing example data for SNP data and the phenotype
#' pfile <- system.file("extdata/phenodata.csv", package = "qtcat")
#' gfile <- system.file("extdata/snpdata.csv", package = "qtcat")
#' pdat <- read.csv(pfile, header = TRUE)
#' snp <- read.snpData(gfile, sep = ",")
#' clust <- qtcatClust(snp)
#' geno <- qtcatGeno(snp, clust)
#' pheno <- qtcatPheno(names = pdat[, 1],
#'                     pheno = pdat[, 2],
#'                     covariates = model.matrix(~ pdat[, 3]))
#' fitted <- qtcatHit(pheno, geno)
#'
#' # fitting a LM to the phenotype and QTC medoids
#' lmfitted <- medoidsLm(fitted, pheno, geno)
#' }
#'
#' @importFrom hit hit
#' @importFrom methods is
#' @export
medoidsLm <- function(object, pheno, geno, alpha = 0.05, min.absCor = 0.05) {
  stopifnot(is(object, "qtcatHit"))
  stopifnot(is(pheno, "qtcatPheno"))
  stopifnot(is(geno, "qtcatGeno"))
  id <- intersect(pheno$names, rownames(geno$x))
  if (!length(id))
    stop("The ID intersect of 'pheno' and 'geno' is emty")
  if (length(id.uniqueGeno <- setdiff(rownames(geno$x), id)))
    cat("The following individuals are part of 'geno' but not of 'pheno':\n",
        paste(id.uniqueGeno, collapse = " "), "\n")
  if (length(id.uniquePheno <- setdiff(pheno$names, id)))
    cat("The following individuals are part of 'pheno' but not of 'geno':\n",
        paste(id.uniquePheno, collapse = " "), "\n")
  sigClust <- summary(object, alpha, min.absCor)
  clusters <- split(rownames(sigClust), sigClust$clusters)
  medoids <- lapply(clusters, function(names, geno) {
    if (length(names) > 1L)
      return(names[which.max(abs(cor(geno$x[, names])))])
    else
      return(names)
  }, geno = geno)
  xg <- geno$x[, colnames(geno$x) %in% unlist(medoids)]
  phenoInx <- which(pheno$names %in% id)
  genoInx <- match(pheno$names[phenoInx], rownames(xg))
  rownames(xg) <- NULL
  if (ncol(pheno$covariates) == 0L)
    dat <- data.frame(y = pheno$pheno[phenoInx], xg[genoInx, ])
  else
    dat <- data.frame(y = pheno$pheno[phenoInx],
                      pheno$covariates[phenoInx, ],
                      xg[genoInx, ])
    lm(y ~ ., data = dat)
}
